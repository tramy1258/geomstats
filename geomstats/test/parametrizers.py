import functools
import inspect
import types

import pytest

import geomstats.backend as gs
from geomstats.exceptions import AutodiffNotImplementedError
from geomstats.test.test_case import autodiff_backend


class Parametrizer(type):
    """Metaclass for test classes.

    Note: A test class is a class that inherits from TestCase.
    For example, `class TestEuclidean(TestCase)` defines
    a test class.

    The Parametrizer helps its test class by pairing:
    - the different test functions of the test class:
      - e.g. the test function `test_belongs`,
    - with different test data, generated by auxiliary test data functions
      - e.g. the test data function `belongs_data` that generates data
      to test the function `belongs`.

    As such, Parametrizer acts as a "metaclass" of its test class:
    `class TestEuclidean(TestCase, metaclass=Parametrizer)`.

    Specifically, Parametrizer decorates every test function inside
    its test class with pytest.mark.parametrizer, with the exception
    of the test class' class methods and static methods.

    Two conventions need to be respected:
    1. The test class should contain an attribute named 'testing_data'.
      - `testing_data` is an object inheriting from `TestData`.
    2. Every test function should have its corresponding test data function created
    inside the TestData object called `testing_data`.

    A sample test class looks like this:

    ```
    class TestEuclidean(TestCase, metaclass=Parametrizer):
        class TestDataEuclidean(TestData):
            def belongs_data():
                ...
                return self.generate_tests(...)
        testing_data = TestDataEuclidean()
        def test_belongs():
            ...
    ```
    Parameters
    ----------
    cls : child class of TestCase
        Test class, i.e. a class inheriting from TestCase
    name : str
        Name of the test class
    bases : TestCase
        Parent class of the test class: TestCase.
    attrs : dict
        Attributes of the test class, for example its methods,
        stored in a dictionnary as (key, value) when key gives the
        name of the attribute (for example the name of the method),
        and value gives the actual attribute (for example the method
        itself.)

    References
    ----------
    More on pytest's parametrizers can be found here:
    https://docs.pytest.org/en/6.2.x/parametrize.html
    """

    def __new__(cls, name, bases, attrs):
        # TODO: bring skip filtering here
        # TODO: use skipif instead? check if collection if performed
        # skip_all = attrs.get("skip_all", False)

        all_test_attrs = _collect_all_tests(attrs, bases)

        testing_data = locals()["attrs"].get("testing_data")
        if testing_data is None:
            raise Exception(
                "Testing class doesn't have class object" " named 'testing_data'"
            )

        data_names_ls = _collect_testing_data_tests(testing_data)
        _check_test_data_pairing(all_test_attrs, data_names_ls)

        # TODO: warn about unused data?

        for attr_name, attr_value in all_test_attrs.copy().items():
            test_func, default_values = _copy_func(attr_value)

            # TODO: move skips to data?
            if (f"skip_{attr_name}", True) in locals()["attrs"].items():
                attrs[attr_name] = pytest.mark.skip("skipped")(test_func)
            else:

                attrs[attr_name] = _parametrize_test_func(
                    test_func, attr_name, testing_data, default_values
                )

        return super().__new__(cls, name, bases, attrs)


class DataBasedParametrizer(type):
    def __new__(cls, name, bases, attrs):
        all_test_attrs = _collect_all_tests(attrs, bases)

        testing_data = locals()["attrs"].get("testing_data")
        if testing_data is None:
            raise Exception(
                "Testing class doesn't have class object named 'testing_data'"
            )

        fail_for_autodiff_exceptions = (
            testing_data.fail_for_autodiff_exceptions
            if hasattr(testing_data, "fail_for_autodiff_exceptions")
            else True
        )
        fail_for_not_implemented_errors = (
            testing_data.fail_for_not_implemented_errors
            if hasattr(testing_data, "fail_for_not_implemented_errors")
            else True
        )

        data_names_ls = _collect_testing_data_tests(testing_data)
        test_attrs_with_data = _filter_test_funcs_given_data(
            all_test_attrs, data_names_ls
        )

        selected_test_attrs, test_attrs_to_skip, _ = _filter_skips_and_ignores(
            test_attrs_with_data, testing_data
        )

        xfails = (
            {_name_to_test_name(name) for name in testing_data.xfails}
            if hasattr(testing_data, "xfails")
            else ()
        )

        for attr_name, attr_value in selected_test_attrs.items():
            test_func, default_values = _copy_func(
                attr_value,
                fail_for_autodiff_exceptions=fail_for_autodiff_exceptions,
                fail_for_not_implemented_errors=fail_for_not_implemented_errors,
            )
            test_func = _parametrize_test_func(
                test_func, attr_name, testing_data, default_values
            )
            if attr_name in xfails:
                test_func = pytest.mark.xfail()(test_func)

            attrs[attr_name] = test_func

        for attr_name, attr_value in test_attrs_to_skip.items():
            test_func, _ = _copy_func(attr_value)
            attrs[attr_name] = pytest.mark.skip()(test_func)

        for attr_name, attr_value in all_test_attrs.items():
            if (
                attr_name not in selected_test_attrs
                and attr_name not in test_attrs_to_skip
            ):
                test_func, _ = _copy_func(attr_value)

                attrs[attr_name] = pytest.mark.ignore()(test_func)

        return super().__new__(cls, name, bases, attrs)


def _except_autodiff_exception(func):
    @functools.wraps(func)
    def _wrapped(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except AutodiffNotImplementedError:
            pass

    return _wrapped


def _except_not_implemented_errors(func):
    @functools.wraps(func)
    def _wrapped(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except NotImplementedError:
            pass

    return _wrapped


def _copy_func(
    f,
    name=None,
    fail_for_autodiff_exceptions=True,
    fail_for_not_implemented_errors=True,
):
    """Copy function.

    Return a function with same code, globals, defaults, closure, and
    name (or provide a new name).

    Additionally, keyword arguments are transformed into positional arguments for
    compatibility with pytest.
    """
    fn = types.FunctionType(
        f.__code__, f.__globals__, name or f.__name__, f.__defaults__, f.__closure__
    )
    fn.__dict__.update(f.__dict__)

    sign = inspect.signature(fn)
    defaults, new_params = {}, []
    for param in sign.parameters.values():
        if param.default is inspect._empty:
            new_params.append(param)
        else:
            new_params.append(inspect.Parameter(param.name, kind=1))
            defaults[param.name] = param.default
    new_sign = sign.replace(parameters=new_params)
    fn.__signature__ = new_sign

    if not fail_for_autodiff_exceptions and not autodiff_backend():
        fn = _except_autodiff_exception(fn)

    if not fail_for_not_implemented_errors:
        fn = _except_not_implemented_errors(fn)

    return fn, defaults


def _check_test_data_pairing(test_attrs, data_names_ls):
    not_paired = []
    for test_name in test_attrs:
        data_name = _test_name_to_test_data_name(test_name)
        if data_name not in data_names_ls:
            not_paired.append(test_name)

    if not_paired:
        msg = "Need to define data for:"
        for test_name in not_paired:
            msg += f"\n\t-{test_name}"

        raise Exception(msg)


def _parametrize_test_func(test_func, attr_name, testing_data, default_values):
    arg_names = inspect.getfullargspec(test_func)[0]
    args_str = ", ".join(arg_names[1:])

    # TODO: allow marks from data in this case?
    # no args case (note selection was done above)
    if len(arg_names) == 1:
        return test_func

    test_data = _get_test_data(
        attr_name,
        testing_data,
        arg_names,
        default_values,
    )

    return pytest.mark.parametrize(args_str, test_data)(test_func)


def _get_test_data(test_name, testing_data, test_arg_names, default_values):
    # assumes pairing test-data exists

    data_name = _test_name_to_test_data_name(test_name)
    test_data = getattr(testing_data, data_name)()

    if test_data is None:
        raise Exception(f"'{data_name}' returned None. should be list")

    test_data = _dictify_test_data(test_data, test_arg_names[1:])

    cls_tols = _get_tolerances(testing_data)
    test_data = _handle_tolerances(
        test_name[5:],
        test_arg_names[1:],
        test_data,
        cls_tols,
    )
    test_data = _pytestify_test_data(
        test_name, test_data, test_arg_names[1:], default_values
    )

    return test_data


def _dictify_test_data(test_data, arg_names):
    tests = []
    for test_datum in test_data:
        if not isinstance(test_datum, dict):
            test_datum = dict(zip(arg_names, test_datum[:-1]))
            test_datum["marks"] = test_datum[-1]

        tests.append(test_datum)

    return tests


def _get_tolerances(testing_data):
    return testing_data.tolerances if hasattr(testing_data, "tolerances") else {}


def _handle_tolerances(func_name, arg_names, test_data, cls_tols):
    has_tol = False
    for arg_name in arg_names:
        if arg_name.endswith("tol"):
            has_tol = True
            break

    if not has_tol:
        return test_data

    func_tols = cls_tols.get(func_name, {})

    tols = {}
    for arg_name in arg_names:
        if arg_name.endswith("rtol"):
            tols[arg_name] = func_tols.get(arg_name, gs.rtol)
        elif arg_name.endswith("tol"):
            tols[arg_name] = func_tols.get(arg_name, gs.atol)

    for test_datum in test_data:
        for tol_arg_name, tol in tols.items():
            test_datum.setdefault(tol_arg_name, tol)

    return test_data


def _pytestify_test_data(func_name, test_data, arg_names, default_values):
    tests = []
    for test_datum in test_data:
        try:
            values = [
                test_datum.get(key) if key in test_datum else default_values[key]
                for key in arg_names
            ]

        except KeyError:
            raise Exception(
                f"{func_name} requires the following arguments: "
                f"{', '.join(arg_names)}"
            )
        tests.append(pytest.param(*values, marks=test_datum.get("marks")))

    return tests


def _is_test(attr_name):
    return attr_name.startswith("test_")


def _is_test_data(attr_name):
    return attr_name.endswith("_test_data")


def _test_name_to_test_data_name(test_name):
    return test_name[5:] + "_test_data"


def _collect_available_tests(attrs):
    return {attr_name: attr for attr_name, attr in attrs.items() if _is_test(attr_name)}


def _collect_available_base_tests(bases):
    base_tests = dict()
    for base in bases:
        base_test_names = [name for name in dir(base) if _is_test(name)]
        for test_name in base_test_names:
            if test_name not in base_tests:
                base_tests[test_name] = getattr(base, test_name)

    return base_tests


def _collect_all_tests(attrs, bases):
    test_attrs = _collect_available_tests(attrs)
    base_attrs = _collect_available_base_tests(bases)

    # order matters
    return base_attrs | test_attrs


def _collect_testing_data_tests(testing_data):
    # TODO: some filtering may occur here
    # TODO: play with `__` for markers? really need this?
    return [attr_name for attr_name in dir(testing_data) if _is_test_data(attr_name)]


def _filter_test_funcs_given_data(test_attrs, data_names_ls):
    # TODO: need to think about skips; probably after
    relevant_test_attrs = dict()
    assigned_data_names = []
    for attr_name, attr in test_attrs.items():
        data_name = _test_name_to_test_data_name(attr_name)
        if data_name in data_names_ls:
            assigned_data_names.append(data_name)
            relevant_test_attrs[attr_name] = attr

    if len(assigned_data_names) != len(data_names_ls):
        missing_tests = set(data_names_ls).difference(assigned_data_names)
        msg = "Need to define tests for:"
        for data_name in missing_tests:
            msg += f"\n\t-{data_name}"

        raise Exception(msg)

    return relevant_test_attrs


def _name_to_test_name(name):
    return f"test_{name}"


def _filter_skips_and_ignores(test_attrs, testing_data):
    """Split data in skips and ignores.

    Notes
    -----
    * `skips` are a list of names
    * `skips_if` are a list of tuples
        * each element is a tuple
        * each tuple contains a evaluated condition and a list of names
    * `ignores_if_not_autodiff` are a list of names
    * `xfails` are treated separately (are a list of names)
    * names should not containt `test_` nor `_test_data`
    """
    selected_test_attrs = {}
    test_attrs_to_skip = {}
    test_attrs_to_ignore = {}

    skips = list(testing_data.skips) if hasattr(testing_data, "skips") else []

    # TODO: review
    skips_if = testing_data.skipif if hasattr(testing_data, "skips_if") else ()
    for skipif in skips_if:
        if skipif[0]:
            skips.extend(skipif[1])

    skips = {_name_to_test_name(name) for name in skips}

    # TODO: remove?
    if not autodiff_backend():
        ignores = (
            set(testing_data.ignores_if_not_autodiff)
            if hasattr(testing_data, "ignores_if_not_autodiff")
            else ()
        )
    else:
        ignores = ()

    ignores = {_name_to_test_name(name) for name in ignores}

    for attr_name, attr_value in test_attrs.items():
        if attr_name in skips:
            test_attrs_to_skip[attr_name] = attr_value
        elif attr_name in ignores:
            test_attrs_to_ignore[attr_name] = attr_value
        else:
            selected_test_attrs[attr_name] = attr_value

    return selected_test_attrs, test_attrs_to_skip, test_attrs_to_ignore
